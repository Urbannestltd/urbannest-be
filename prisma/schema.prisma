generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserStatus {
  PENDING
  ACTIVE
  BLOCKED
}

enum RoleType {
  ADMIN
  LANDLORD
  TENANT
  VENDOR
}

enum PropertyType {
  MULTI_UNIT
  SINGLE_FAMILY
  COMMERCIAL
}

enum UnitStatus {
  AVAILABLE
  OCCUPIED
  MAINTENANCE
}

enum LeaseStatus {
  ACTIVE
  EXPIRED
  TERMINATED
}

enum PaymentStatus {
  PENDING
  PAID
  OVERDUE
  FAILED
}

enum PaymentType {
  RENT
  UTILITY_BILL
  UTILITY_TOKEN
  SERVICE_CHARGE
}

enum UtilityType {
  ELECTRICITY
  WATER
  SERVICE_CHARGE
  WASTE
  INTERNET
}

enum VisitorType {
  GUEST // Friends, Family
  DELIVERY // Jumia, DHL, Food
  SERVICE_PROVIDER // Plumber, Cleaner, IT Support
}

enum InviteFrequency {
  ONE_OFF
  WHOLE_DAY
  RECURRING
}

enum InviteStatus {
  ACTIVE
  EXPIRED
  REVOKED
  COMPLETED
  UPCOMING
  CHECKED_IN
  CHECKED_OUT
}

enum SupportCategory {
  BILLING
  ACCOUNT_ISSUE
  APP_BUG
  DISPUTE
  OTHER
}

enum SupportStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum SupportPriority {
  LOW
  MEDIUM
  HIGH
}

enum MaintenanceCategory {
  PLUMBING
  ELECTRICAL
  HVAC // Heating, Ventilation, AC
  APPLIANCE
  STRUCTURAL // Walls, Windows, Roof
  PEST_CONTROL
  OTHER
}

enum MaintenancePriority {
  LOW
  MEDIUM
  HIGH
  EMERGENCY
}

enum MaintenanceStatus {
  PENDING
  IN_PROGRESS
  RESOLVED
  CANCELLED
}

model user {
  userId               String   @id @default(uuid())
  userFirstName        String?
  userFullName         String?
  userPhone            String?
  userEmail            String   @unique
  userPassword         String?
  userGoogleId         String?  @unique
  userRole             role     @relation(fields: [userRoleId], references: [roleId])
  userRoleId           String
  userStatus           String   @default("PENDING")
  userCreatedAt        DateTime @default(now())
  userUpdatedAt        DateTime @updatedAt
  userProfileUrl       String?
  userEmergencyContact String?

  ownedProperties property[]       @relation("landlordProperties")
  leases          lease[]          @relation("tenantLeases")
  utilityProfiles utilityProfile[]
  payments        payment[]

  otpLogs             otpLogs[]
  passwordResetTokens passwordReset[]
  registrationLinks   userRegistrationLink[]
  visitorInvites      VisitorInvite[]

  assignedTickets     MaintenanceRequest[] @relation("AssignedTickets")
  sentMessages        MaintenanceMessage[]
  supportTickets      SupportTicket[]
  supportMessages     SupportMessage[]
  maintenanceRequests MaintenanceRequest[]
  visitorGroups       VisitorGroup[]

  notificationSettings NotificationSetting?
  reminders            Reminder[]

  paymentMethods PaymentMethod[]

  isTwoFactorEnabled Boolean @default(false)
  twoFactorSecret    String?
  twoFactorExpiry    DateTime?

  @@map("user")
}

model role {
  roleId          String   @id @default(uuid())
  roleName        String   @unique
  roleDescription String?
  roleStatus      String   @default("ACTIVE")
  roleCreatedAt   DateTime @default(now())
  roleUpdatedAt   DateTime @updatedAt

  users user[]
}

model privilege {
  privilegeId          String   @id @default(uuid())
  privilegeName        String   @unique
  privilegeDescription String?
  privilegeStatus      String   @default("ACTIVE")
  privilegeCreatedAt   DateTime @default(now())
  privilegeUpdatedAt   DateTime @updatedAt
}

model otpLogs {
  otpLogId        String   @id @default(uuid())
  otpLogHash      String
  otpLogUserId    String
  otpLogUser      user     @relation(fields: [otpLogUserId], references: [userId])
  otpLogStatus    String   @default("ACTIVE")
  otpLogExpiry    DateTime
  otpLogCreatedAt DateTime @default(now())
  otpLogUpdatedAt DateTime @updatedAt
}

model userRegistrationLink {
  userRegistrationLinkId        String   @id @default(uuid())
  userRegistrationLinkToken     String   @unique
  userRegistrationLinkExpiresAt DateTime

  userRegistrationLinkUserId String
  userRegistrationLinkUser   user   @relation(fields: [userRegistrationLinkUserId], references: [userId], onDelete: Cascade)

  userRegistrationLinkUsed      Boolean @default(false)
  userRegistrationLinkIpAddress String?

  userRegistrationLinkCreatedAt DateTime @default(now())
  userRegistrationLinkUpdatedAt DateTime @updatedAt
}

model passwordReset {
  passwordResetId        String   @id @default(uuid())
  passwordResetToken     String   @unique
  passwordResetExpiresAt DateTime

  passwordResetUserId String
  passwordResetUser   user   @relation(fields: [passwordResetUserId], references: [userId], onDelete: Cascade)

  passwordResetUsed      Boolean @default(false)
  passwordResetIpAddress String?

  passwordResetCreatedAt DateTime @default(now())
  passwordResetUpdatedAt DateTime @updatedAt
}

model property {
  id      String       @id @default(uuid()) @map("property_id")
  name    String?      @map("name")
  address String       @map("address")
  city    String       @map("city")
  state   String       @map("state")
  zip     String       @map("zip_code")
  type    PropertyType @default(MULTI_UNIT) @map("type")

  landlordId String @map("landlord_id")
  landlord   user   @relation("landlordProperties", fields: [landlordId], references: [userId])

  units unit[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("properties")
}

// 2. THE UNIT (The specific Flat/Apartment)
model unit {
  id        String     @id @default(uuid()) @map("unit_id")
  name      String     @map("name") // "Apt 4B"
  bedrooms  Int        @default(1) @map("bedrooms")
  bathrooms Float      @default(1.0) @map("bathrooms")
  status    UnitStatus @default(AVAILABLE) @map("status")

  propertyId String   @map("property_id")
  property   property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  leases lease[]

  createdAt           DateTime             @default(now()) @map("created_at")
  updatedAt           DateTime             @updatedAt @map("updated_at")
  visitorInvites      VisitorInvite[]
  maintenanceRequests MaintenanceRequest[]
  visitorGroups       VisitorGroup[]

  @@map("units")
}

model lease {
  id          String      @id @default(uuid()) @map("lease_id")
  startDate   DateTime    @map("start_date")
  endDate     DateTime    @map("end_date")
  rentAmount  Float       @map("rent_amount")
  status      LeaseStatus @default(ACTIVE) @map("status")
  documentUrl String?     @map("document_url")

  // Relations
  unitId String @map("unit_id")
  unit   unit   @relation(fields: [unitId], references: [id])

  tenantId String @map("tenant_id")
  tenant   user   @relation("tenantLeases", fields: [tenantId], references: [userId])

  payments     payment[]
  utilityBills utilityBill[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("leases")
}

model utilityProfile {
  id         String      @id @default(uuid()) @map("id")
  type       UtilityType @map("type")
  provider   String?     @map("provider")
  identifier String      @map("identifier")
  label      String?     @map("label")

  userId String @map("user_id")
  user   user   @relation(fields: [userId], references: [userId])

  createdAt DateTime @default(now()) @map("created_at")

  @@map("utility_profiles")
}

model utilityBill {
  id          String        @id @default(uuid()) @map("id")
  type        UtilityType   @map("type")
  amount      Float         @map("amount")
  dueDate     DateTime      @map("due_date")
  status      PaymentStatus @default(PENDING) @map("status")
  description String?       @map("description")

  leaseId String @map("lease_id")
  lease   lease  @relation(fields: [leaseId], references: [id])

  paymentId String?  @unique @map("payment_id")
  payment   payment? @relation(fields: [paymentId], references: [id])

  createdAt DateTime @default(now()) @map("created_at")

  @@map("utility_bills")
}

model payment {
  id        String        @id @default(uuid()) @map("payment_id")
  amount    Float         @map("amount")
  dueDate   DateTime?     @map("due_date")
  paidDate  DateTime?     @map("paid_date")
  status    PaymentStatus @default(PENDING) @map("status")
  reference String        @unique @map("reference")
  type      PaymentType   @default(RENT) @map("type")

  utilityType  UtilityType? @map("utility_type")
  utilityToken String?      @map("utility_token")
  meterNo      String?      @map("utility_meter_no")

  metadata Json? @map("metadata")

  // Relations
  userId String @map("user_id")
  user   user   @relation(fields: [userId], references: [userId])

  leaseId String? @map("lease_id")
  lease   lease?  @relation(fields: [leaseId], references: [id])

  utilityBill utilityBill?

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("payments")
}

model VisitorGroup {
  id       String @id @default(uuid())
  tenantId String
  unitId   String

  name String // e.g. "Project Team", "Birthday Bash"

  // Shared Timing Constraints (The "Event" time)
  validFrom  DateTime
  validUntil DateTime

  // Relations
  invites VisitorInvite[] // One Group has Many Visitors
  tenant  user            @relation(fields: [tenantId], references: [userId])
  unit    unit            @relation(fields: [unitId], references: [id])

  createdAt DateTime @default(now())
}

// 2. Updated Child Model
model VisitorInvite {
  id String @id @default(uuid())

  // Keep these for fast queries (Verification doesn't need to join tables)
  tenantId String
  unitId   String

  // === NEW: Link to the Group ===
  groupId String?
  group   VisitorGroup? @relation(fields: [groupId], references: [id])

  visitorName  String
  visitorPhone String?
  accessCode   String  @unique

  // Timestamps (Copied from Group for performance, or set individually)
  validFrom  DateTime
  validUntil DateTime

  type      VisitorType     @default(GUEST)
  frequency InviteFrequency @default(ONE_OFF)
  status    InviteStatus    @default(ACTIVE)

  // Relations
  tenant user @relation(fields: [tenantId], references: [userId])
  unit   unit @relation(fields: [unitId], references: [id])

  createdAt    DateTime  @default(now())
  checkedInAt  DateTime?
  checkedOutAt DateTime?

  @@index([accessCode])
  @@index([groupId]) // Index for fetching "All guests in this group"
}

// model VisitorInvite {
//   id       String @id @default(uuid())
//   tenantId String
//   unitId   String

//   visitorName  String
//   visitorPhone String?

//   accessCode String @unique

//   // TIME CONTROL
//   validFrom  DateTime // Start of the window (e.g. 9:00 AM)
//   validUntil DateTime // End of the window (e.g. 5:00 PM)

//   // CATEGORIZATION
//   type      VisitorType     @default(GUEST) // Who is it?
//   frequency InviteFrequency @default(ONE_OFF) // One-off or Recurring?

//   status InviteStatus @default(ACTIVE)

//   // Relations
//   tenant user @relation(fields: [tenantId], references: [userId])
//   unit   unit @relation(fields: [unitId], references: [id])

//   createdAt    DateTime  @default(now())
//   checkedInAt  DateTime?
//   checkedOutAt DateTime?

//   @@index([accessCode])
// }

model SupportTicket {
  id       String @id @default(uuid())
  tenantId String

  category SupportCategory
  subject  String
  status   SupportStatus   @default(OPEN)
  priority SupportPriority @default(LOW)

  messages SupportMessage[]

  // Relations
  tenant user @relation(fields: [tenantId], references: [userId])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model SupportMessage {
  id       String @id @default(uuid())
  ticketId String
  senderId String // Tenant or Admin ID

  message     String
  attachments String[] // URL strings

  ticket SupportTicket @relation(fields: [ticketId], references: [id])
  sender user          @relation(fields: [senderId], references: [userId])

  createdAt DateTime @default(now())
}

model MaintenanceRequest {
  id       String @id @default(uuid())
  tenantId String
  unitId   String

  category MaintenanceCategory
  priority MaintenancePriority @default(MEDIUM)
  status   MaintenanceStatus   @default(PENDING)

  subject     String?
  description String
  attachments String[] // Array of Image/Video URLs

  // Relations
  tenant user @relation(fields: [tenantId], references: [userId])
  unit   unit @relation(fields: [unitId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  assignedToId String? // ID of the Facility Manager/Vendor handling this

  messages MaintenanceMessage[] // Relation to chat history

  // Relation for assignment
  assignedTo user? @relation("AssignedTickets", fields: [assignedToId], references: [userId])

  @@index([unitId])
  @@index([status])
}

// New Model: Chat Messages
model MaintenanceMessage {
  id       String @id @default(uuid())
  ticketId String
  senderId String // Could be Tenant OR Manager

  message     String
  attachments String[] // Images/Videos sent in chat

  // Relations
  ticket MaintenanceRequest @relation(fields: [ticketId], references: [id])
  sender user               @relation(fields: [senderId], references: [userId])

  createdAt DateTime  @default(now())
  readAt    DateTime? // To show "Read" receipts
}

model PaymentMethod {
  id     String @id @default(uuid())
  userId String

  // Paystack Data
  authorizationCode String // The "Token" to charge the card later
  last4             String // e.g., "4321"
  cardType          String // e.g., "Visa", "Mastercard"
  bank              String? // e.g., "GTBank"
  expMonth          String
  expYear           String

  isDefault Boolean  @default(false)
  createdAt DateTime @default(now())

  user user @relation(fields: [userId], references: [userId])
}

model NotificationSetting {
  id     String @id @default(uuid())
  userId String @unique

  // Matches the checkboxes in your UI
  emailPayments    Boolean @default(true)
  emailLease       Boolean @default(true)
  emailMaintenance Boolean @default(true)
  emailVisitors    Boolean @default(true)

  // Future proofing for Push Notifications
  pushPayments    Boolean @default(false)
  pushMaintenance Boolean @default(false)

  user user @relation(fields: [userId], references: [userId])
}

model Reminder {
  id     String @id @default(uuid())
  userId String

  title       String // e.g. "Pay Rent"
  description String?
  dueAt       DateTime // When to remind

  isSent    Boolean  @default(false) // Has the system sent the email/push yet?
  createdAt DateTime @default(now())

  user user @relation(fields: [userId], references: [userId])
}
